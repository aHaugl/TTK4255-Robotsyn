import sympy as sp
import numpy as np
from matplotlib import pyplot as plt
from scipy.spatial.transform import Rotation
import pprint

from homography import estimate_H, decompose_H
from autogenerated.platfrom import get_platform_T, get_platform_T_diff
from utils import project, get_uv_jac
from methods import levenberg_marquardt

K = np.loadtxt('../data/K.txt')
platform_to_camera = np.loadtxt('../data/platform_to_camera.txt')

platform_corners_metric = np.loadtxt('../data/platform_corners_metric.txt')
platform_corners_image = np.loadtxt('../data/platform_corners_image.txt')

img = plt.imread('../data/quanser_image_sequence/video0000.jpg')


corners_image_XY1 = np.vstack((platform_corners_image,
                               np.ones(platform_corners_image.shape[1])))
corners_metric_XY1 = platform_corners_metric[[0, 1, 3]]

platform_corners_camera = np.linalg.inv(K) @ corners_image_XY1


H = estimate_H(platform_corners_camera[:2], platform_corners_metric[:2])
T = decompose_H(H)


state_init = np.hstack((T[:3, 3],
                        Rotation.from_matrix(T[:3, :3]).as_euler('xyz')))


def residuals(state):
    T = get_platform_T(state)
    uv_hat = project(K, T@platform_corners_metric)
    return (uv_hat-platform_corners_image).reshape(-1)


def diff(state):
    T = get_platform_T(state)
    T_diff = get_platform_T_diff(state)
    points = platform_corners_metric
    diff_state, diff_points = get_uv_jac(K, T, T_diff, points)
    return diff_state


optimal_state = levenberg_marquardt(residuals, diff, state_init)
T_opt = get_platform_T(optimal_state)


def residuals_3(state):
    T = get_platform_T(state)
    uv_hat = project(K, T@platform_corners_metric[:, :3])
    return (uv_hat-platform_corners_image[:, :3]).reshape(-1)


def diff_3(state):
    T = get_platform_T(state)
    T_diff = get_platform_T_diff(state)
    points = platform_corners_metric[:, :3]
    diff_state, diff_points = get_uv_jac(K, T, T_diff, points)
    return diff_state


config_set = set()
config_set.add(tuple(np.round(T_opt.ravel(), 2)))
iteration = 0
while len(config_set) < 2:
    state_init_3 = state_init.copy()
    state_init_3[:3] *= np.random.random(1)*(10-0.1) + 0.1
    state_init_3[3:] = (np.random.random(3)*2-1)*np.pi
    optimal_state_3 = levenberg_marquardt(residuals_3, diff_3, state_init_3,
                                          max_iterations=1000,
                                          min_stepsize=1e-4)

    if np.sum(residuals_3(optimal_state_3)**2) < 100:
        T_opt_3 = get_platform_T(optimal_state_3)
        rounded = tuple(np.round(T_opt_3.ravel(), 2))
        if rounded not in config_set:
            config_set.add(rounded)


projection_KH = project(K, H@corners_metric_XY1)
projection_KRt = project(K, T@platform_corners_metric)
projection_T_opt = project(K, T_opt@platform_corners_metric)

rep_err_KH = np.linalg.norm(
    (projection_KH - platform_corners_image), axis=0)
rep_err_KRt = np.linalg.norm(
    (projection_KRt - platform_corners_image), axis=0)
rep_err_T_opt = np.linalg.norm(
    (projection_T_opt - platform_corners_image), axis=0)

print('The optimal T matrix is:')
pprint.pprint(np.round(T_opt, 3))

print('\nAnother possible T matrix for the 3 first points is:')
pprint.pprint(np.round(T_opt_3, 3))

plt.close('all')
fig1, ax1 = plt.subplots()
size = 40.
ax1.imshow(img)
scatter_KH = ax1.scatter(*projection_KH, s=8*size, c='r')
scatter_KRt = ax1.scatter(*projection_KRt, s=4*size, c='g')
scatter_T_opt = ax1.scatter(*projection_T_opt, 2*size, c='k')
true_corners = ax1.scatter(*platform_corners_image, s=0.6*size,
                           color='w', linewidths=1, edgecolor='k')
ax1.set_xlim((200, 500))
ax1.set_ylim((600, 400))

plt.legend((true_corners, scatter_KH, scatter_KRt, scatter_T_opt),
           ('True corners', 'H (2.1a)', '[R t] (2.1b)',
            'Levenberg-Marquardt (2.2)'),
           scatterpoints=1,
           loc='lower right',
           ncol=2)

fig2, ax2 = plt.subplots()
ax2.plot(rep_err_KH, c='r', label='H (2.1a)')
ax2.plot(rep_err_KRt, c='g', label='[R t] (2.1b)')
ax2.plot(rep_err_T_opt, c='k', label='Levenberg-Marquardt(2.2)')
plt.legend()
plt.xlabel('Point')
plt.ylabel('Reprojection error [px]')
plt.xticks(np.arange(4))
plt.show()
