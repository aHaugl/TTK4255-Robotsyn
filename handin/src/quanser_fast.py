import numpy as np
import numba as nb
from utils import get_uv_jac, project
from autogenerated.heli_system import (get_arm_T, get_arm_T_diff,
                                       get_rotors_T, get_rotors_T_diff,
                                       get_hing_T, get_base_T, get_platform_T)
from matplotlib import pyplot as plt
from common import draw_frame


K = np.loadtxt('../data/K.txt')
heli_points = np.loadtxt('../data/heli_points.txt').T
arm_points = heli_points[:, :3].copy()
rotors_points = heli_points[:, -4:].copy()


@nb.njit(cache=True, parallel=True)
def get_u_hat(states, points):
    arm_points = points[:, :3]
    rotors_points = points[:, -4:]
    arm_T = get_arm_T(states)
    rotors_T = get_rotors_T(states)
    arm_uv = project(K, arm_T @ arm_points)
    rotors_uv = project(K, rotors_T @ rotors_points)
    uv_hat = np.hstack((arm_uv, rotors_uv))
    return uv_hat


@nb.njit(cache=True, parallel=True)
def get_resiudials(uv, weights, states, points):
    uv_hat = get_u_hat(states, points)
    return ((uv_hat-uv) * weights.reshape(1, -1)).reshape(-1)


@nb.njit(cache=True, parallel=True)
def get_resiudials_diff(weights, states, points):
    arm_points = points[:, :3]
    rotors_points = points[:, -4:]

    n_states = states.shape[0]
    n_points = points.shape[1]
    n_args = n_states + 3*n_points

    padded_eye = np.ones((4, 3))
    padded_eye[:3, :3] = np.eye(3)

    arm_T = get_arm_T(states)
    arm_T_diff = get_arm_T_diff(states)
    arm_uv_diff_state,  arm_uv_diff_points = get_uv_jac(
        K, arm_T, arm_T_diff, arm_points)

    rotors_T = get_rotors_T(states)
    rotors_T_diff = get_rotors_T_diff(states)
    rotors_uv_diff_state,  rotors_uv_diff_points = get_uv_jac(
        K, rotors_T, rotors_T_diff, rotors_points)

    uv_diff = np.zeros((n_points*2, n_args))
    uv_diff[:, :n_states] = np.hstack((
        arm_uv_diff_state.reshape(2, -1, n_states),
        rotors_uv_diff_state.reshape(2, -1, n_states))
    ).reshape(-1, n_states)

    # TODO make this cleaner
    for xyz in range(3):
        u_part = uv_diff[:n_points, n_states:]
        u_part[:3, xyz*7:xyz*7+3] = arm_uv_diff_points[:3, xyz*3:xyz*3+3]
        u_part[3:, xyz*7+3:xyz*7+7] = rotors_uv_diff_points[:4, xyz*4:xyz*4+4]

        v_part = uv_diff[n_points:, n_states:]
        v_part[:3, xyz*7:xyz*7+3] = arm_uv_diff_points[3:, xyz*3:xyz*3+3]
        v_part[3:, xyz*7+3:xyz*7+7] = rotors_uv_diff_points[4:, xyz*4:xyz*4+4]

    weights = np.hstack((weights, weights))
    return (uv_diff * weights.reshape(-1, 1))


class Quanser:
    def __init__(self):
        self.K = np.loadtxt('../data/K.txt')
        self.heli_points = np.loadtxt('../data/heli_points.txt').T
        self.platform_to_camera = np.loadtxt('../data/platform_to_camera.txt')

    def residuals(self, uv, weights, states, points, get_T_mat=False):
        residuals = get_resiudials(uv, weights, states, points)

        if get_T_mat:
            self.rotors_to_camera = get_rotors_T(states)
            self.arm_to_camera = get_arm_T(states)
            self.hinge_to_camera = get_hing_T(states)
            self.base_to_camera = get_base_T(states)
            self.platform_to_camera = get_platform_T(states)
            self.uv_hat = get_u_hat(states, points)
        return residuals

    def draw(self, uv, weights, image_number):
        img = plt.imread(
            '../data/quanser_image_sequence/video%04d.jpg' % image_number)
        plt.imshow(img)
        plt.scatter(*uv[:, weights == 1], linewidths=1,
                    edgecolor='black', color='white', s=80, label='Observed')

        plt.scatter(*self.uv_hat, color='red', label='Predicted', s=10)
        plt.legend()
        plt.title('Reprojected frames and points on image number %d' %
                  image_number)
        draw_frame(self.K, self.platform_to_camera, scale=0.05)
        draw_frame(self.K, self.base_to_camera, scale=0.05)
        draw_frame(self.K, self.hinge_to_camera, scale=0.05)
        draw_frame(self.K, self.arm_to_camera, scale=0.05)
        draw_frame(self.K, self.rotors_to_camera, scale=0.05)
        plt.xlim([0, img.shape[1]])
        plt.ylim([img.shape[0], 0])
        plt.savefig('../output/out_reprojection.png')
