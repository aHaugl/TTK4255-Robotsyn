import sympy as sp
from sympy.printing.pycode import NumPyPrinter
import re
import autopep8

"""
This file 
"""


def numbafy(name, expression, variables=None,
            signature=None):
    """
    Get the str of a function that takes the variables as input and return 
    the evaluated expression
    """
    signature = signature or 'float64[:,::1](float64[:])'
    cse = sp.cse(expression, optimizations='basic')
    np_printer = NumPyPrinter()
    variables = variables or expression.free_symbols
    arg1 = 'states'

    code = ''
    dec = "@nb.njit(cache=True)\n"
    code += dec
    code += f'def {name}({arg1}):\n'
    var_string = ', '.join([str(var) for var in variables])
    code += f'\t"""\n\t{var_string}\n\t"""\n\n'
    for i, var in enumerate(variables):
        code += f'\t{var} = {arg1}[{i}]\n'
    code += '\n'
    for assignment in cse[0]:
        code += f'\t{np_printer.doprint(*assignment[::-1])}\n'

    code += '\n'

    retval = np_printer.doprint(cse[1][0]).replace('], [', '],\n[')
    retval = re.sub(r'(?<=[^\.\w])(\d+)(?=[^\.\w])', r'\g<1>.', retval)

    code += '\treturn '
    code += retval
    code = code.replace('numpy', 'np')
    return autopep8.fix_code(code)


def create_numba_file(filename, functions):
    """
    Creates a python file containing the code to evaluate all the functions
    """
    code = ''
    code += 'import numpy as np\n'
    code += 'import numba as nb\n'

    for func in functions:
        name, expression, variables = func[:3]
        signature = func[3] if len(func) > 3 else None

        code += '\n\n'
        code += numbafy(name, expression, variables, signature)

    with open(f'autogenerated/{filename}.py', 'w') as file:
        file.write(code)
